---
title: "Scoping rules"
author: "Akis"
date: "01/02/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Lexical Scoping

```{r}
f <- function(x, y) {
  x^2 + y / z
}
```

This function has 2 formal arguments **x** and **y**. In the body of the function there is another zymbol **z**. In this case **z** is called a *free* variable. The scoping rules of a language determine how values are assigned to free variables. Free variables are not formal arguments and are not local variables (assigned inside the function body).

Lexical scoping in R means that 
*the values of free variables are searched for in the environment in which the function was defined.*
* An environment is a collection of symbol, value) pairs, i.e. **x** is a symbol and 3.14 might be its value. Every symbol has a value bound to it.
* Every environment has a parent environment; it is possible for an environment to have multiple "children"
* The only envionment without a parent is the empty environment
* A function + an environment = a **closure or function closure**

## Binding values to symbol

* Environment = lists of objects/symbols and values
* Global environment = your workspace - it consists of all the things that you defined or loaded into R.

When R tried to bind a value to asymbol, it searches through a series of **environments** to find the appropriate value.

1. Search the global environment for a ymbol name matching the one requested.
2. Search the namespaces of each of the packages on the search list (search list can be found using the **search()** function).

```{r}
search()
```

* The scoping rules determine how a value is associated with a free variable in a function
* R uses **lexical** scoping or **static** scoping. A common alternative is **dynamic** scoping.
* Lexical scoping turns out to be particularly useful for simplifying statistical computations.

# Why scoping matters?

* Typically a function is defined in the global environment, so that the values of free variables are just found in the user's workspace.
* In R you can have function defined *inside other functions*. Languages like C don't allow this.
* In this case the environment in which a function is defined is the body of another function.

Example:
```{r}
make.power <- function(n) {
  pow <- function(x) {
    x^n
  }
  pow
}

make.power(3)

cube <- make.power(3)
square <- make.power(2)
cube(3) # 3^3
square(3) # 3^2
```

Question: Why **make.power(3)** returns the value of the function **pow** (which is the function itself), but when we store **make.power(3)** to object **cube** and then call **cube(3)** we get the right output?

* If the value of a symbol is not found in the environment in which a function was defined, then the search is continued in the *parent environment*.
* The search continues down the sequence of parent environments until we hit the *top-level environment*; this is usually the global environment (workspace) or the namespace of a package.
* After the top-level environment, the search continues down th search list until we hit the *empty environment*. If a value for a given symbol cannot be found once the empty environment is arrived at, then an error is thrown.

Answer:  The **make.power** function returns the function **pow** as its value.

The symbol **n** is a free variable in the**pow** function. However, **n** is defined in the **make.power** function.

Moving from one level (environment) to the next





